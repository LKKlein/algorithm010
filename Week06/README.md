## 动态规划思维要点

MIT版本：

1. 定义重复子问题
2. 思考——可能求解的方式，递推方程
3. 合并子问题的解
4. 递归 & 记忆化  或者 建立递归的状态表（自底向上）
5. 处理原问题

超哥版本：

1. 找出重复子问题（分治）
2. **定义状态数组（维度，值表示什么）**
3. **建立DP方程**



**关键点：关键在于第2、3步，如何把问题转化为一个状态数组，如何定义问题的状态转移方程**

另外，在回溯自顶向下的思维上，如何转变为自底向上的动态规划思维



## 题解分析：

1. 爬楼梯
   - 状态数组：`dp = []`, 一维数组，节点表示到达该层楼梯可能的走法数量
   - 状态边界：`dp[0] = 0，dp[1] = 1, dp[2] = 2`
   - 状态转移方程：`dp[i] = dp[i - 1] + dp[i - 2]`
   
   **技巧：「状态压缩」，如果我们发现每次状态转移只需要 DP数组 中的一部分，那么可以尝试用状态压缩来缩小 DP数组 的大小，只记录必要的数据，这里可以使用三个变量代替DP数组**
2. 不同路径
   - 状态数组：`dp = [][]`，与原始矩阵相同的二维矩阵，每个点表示到达该点可能的走法数量
   - 状态边界：第一行和第一列均为 1 种走法，`dp[i][0] = dp[0][j] = 1`
   - 状态转移方程：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`
3. 不同路径二
   - 状态数组：`dp = [][]`，同样与原始矩阵相同的二维矩阵，每个点表示到达该点可能的走法数量
   - 状态边界：第一行和第一列均为 1 种走法，`dp[i][0] = dp[0][j] = 1`，但是如果中间有障碍物，那么后面都为0
   - 状态转移方程：
     - `dp[i][j] = dp[i - 1][j] + dp[i][j - 1], if grid[i][j] != 1`
     - `dp[i][j] = 0, if grid[i][j] == 0`
   
   **2，3 均可以将DP方程优化为一维数组，只包含第一行或第一列元素长度的数组，依次向下或向右递推，取最后一个值即可**
   
4. [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

   - 状态数组：`dp = [][]`，二维数组，将两个字符串字符一一对应形成矩阵，dp数组中每个点表示两个当前这个节点之前的前缀字符串之间的最长公共子序列长度
   - 状态边界：
     - 第一行和第一列可以一个for循环直接判断，遇到该字符之前为0，遇到之后全部为1
     - 另一种做法，两个字符串前面都加一个非字母的不同字符，这样第一行，第一列都为0
   - 状态转移方程：
     - `dp[i][j] = dp[i - 1][j - 1] + 1, if s1[i] == s2[j]`
     - `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), if s1[i] != s2[j]`
5. 三角形的最小路径之和
   - 状态数组：`dp = []` ，一维数组，每个节点表示当前这一行，每一列的最小路径之和
   - 状态边界：初始化为三角形最后一行的值
   - 状态转移方程：`dp[j] = min(dp[j], dp[j + 1]) + triangle[i - 1][j]`，依次向上反向推导
6. 最大子序和
   - 状态数组：`dp = []`，一维数组，每个节点表示当前这个节点的最大子序列的和
   - 状态边界：`dp[0] = nums[0]`
   - 状态转移方程：`dp[i] = max(dp[i - 1], 0) + nums[i]`
7. 乘积最大子数组
   - 状态数组：`dp = [2][]`，二维数组，也可以换成两个一维的DP数组，分别表示当前节点的最大子序列的乘积 （正数），以及当前这个节点的最小子序列的乘积 （负数）
   - 状态边界：`dp[0][0] = dp[1][0] = nums[0]`
   - 状态转移方程： 当前值小于0时，最大最小值交换
     - `dp[0][i] = max(dp[0][i - 1], 1) * nums[i], dp[1][i] = max(dp[1][i - 1], 1) * nums[i], if nums[i] >= 0`
     - `dp[0][i] = max(dp[1][i - 1], 1) * nums[i], dp[1][i] = max(dp[0][i - 1], 1) * nums[i], if nums[i] < 0`
8. 零钱兑换
   - 状态数组：`dp = []`，一维数组，每个节点表示当前节点金额需要的最少金币数量
   - 状态边界：`dp[0] = 0`，所有元素初始化为最大金额数加一，或者无穷大也可以，反正就是怎么凑都到不了这个数字
   - 状态转移方程：`dp[i] = min([dp[i - k] if i >= k else max_ for k in coins]) + 1`
9. 打家劫舍
   - 状态数组：`dp = [][2]`，二维数组，第二维为2个数字，分别表示在第`i`家时偷和不偷时的最大金额数
   - 状态边界：`dp[0][0] = nums[0], dp[0][0] = 0`
   - 状态转移方程：
     - `dp[i][0] = max(dp[i - 1][1], 0) + nums[i]`
     - `dp[i][1] = max(dp[i - 1][0], dp[i - 1][1])`
   - 优化：
     - `dp = []`， 一维数组，表示到第`i`家时必偷的最大金额数
     - `dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`  或者 `dp[0] = 0, dp[1] = nums[0]`
     - `dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])`

